subscriber_information.id_abon - PK
------------------------------------ДЕНИС-----------------------------
г)
period_traffic.id_abon - PK(составной ключ) / FK(subscriber_information.id_abon)
period_traffic.day - PK (составной ключ)
------------------------------------ОЛЯ-------------------------------
в)
house_info.id_abon - PK / FK(subscriber_information.id_abon)
------------------------------------МАКС------------------------------
а)!!!!!! у меня составной ключ
abon_cities.id_abon - PK / FK(subscriber_information.id_abon)
abon_cities.city - PK

----
states.city PK / FK(abon_cities.city)
------------------------------------СОФЬЯ-----------------------------
б)
abon_podkl.id_abon FK(subscriber_information.id_abon)
abon_podkl.id_podkl PK
----
abon_spis.id_podkl PK / FK(abon_podkl.id_podkl)
----
abon_sales.id_podkl PK / FK(abon_podkl.id_podkl)



1. Написать триггер для subscriber_information
   Параметрами будут before insert
   Задача триггера добавлять текущую дату в поле comment_when_сonnecting при добавлении новых записей

CREATE DEFINER=`den`@`%` TRIGGER `subscriber_information_BEFORE_INSERT` BEFORE INSERT ON `subscriber_information` FOR EACH ROW BEGIN
SET NEW.comment_when_сonnecting=DATE(now());
END

2. Написать процедуру.
   Входящие атрибуты :
        id_abon,
        first_name,
        last_name,
        connection_date,
        trust_payment,
        number_of_internet_devices,
        number_of_tv_devices,
        comment_when_сonnecting
   Задача процедуры, добавить данные из входящих атрибутов в таблицу subscriber_information.


CREATE DEFINER=`den`@`%` PROCEDURE `insert_into_si`(
in id_abon varchar(50) ,
in first_name varchar(25),
in last_name varchar(25) ,
in connection_date date ,
in trust_payment int ,
in number_of_internet_devices int ,
in number_of_tv_devices int ,
in comment_when_сonnecting varchar(100)
)
BEGIN
		INSERT INTO `data_set`.`subscriber_information`
			(`id_abon`,`first_name`,`last_name`,`connection_date`,`trust_payment`,`number_of_internet_devices`,`number_of_tv_devices`,`comment_when_сonnecting`)
	 		VALUES (id_abon,first_name,last_name,connection_date,trust_payment,number_of_internet_devices,number_of_tv_devices,comment_when_сonnecting);
		
END

CALL `data_set`.`insert_into_si` ('2','Test','Test','2020-01-01',1,0,0,null);

3. Написать триггеры для всех таблиц, которые имеют связь по FK с таблицей subscriber_information.
   Параметрами будут before insert
   Задача триггеров проверять поле id_abon или составных PK на предмет дублирующей записи. В случае подтверждения дубликата, выводить надпись
  "id_abon for X... already available" , где 'X...' номер id.

а) для abon_cities - 2PK


CREATE DEFINER=`den`@`%` TRIGGER `abon_cities_unic` BEFORE INSERT ON `abon_cities` FOR EACH ROW BEGIN

IF CONCAT(NEW.id_abon,NEW.city) in (select CONCAT(id_abon,city) from abon_cities) Then
SET @me_text=CONCAT('id_abon for ', NEW.id_abon,' and city ', NEW.city,' already available');
	SIGNAL sqlstate '45000'
			SET message_text = @me_text;
	END IF;
END

б) для abon_podkl

CREATE DEFINER=`den`@`%` TRIGGER `abon_podkl_BEFORE_INSERT` BEFORE INSERT ON `abon_podkl` FOR EACH ROW BEGIN
IF NEW.id_abon in (select id_abon from abon_podkl) Then
SET @me_text_1=CONCAT('id_abon for ', NEW.id_abon,' already available');
	SIGNAL sqlstate '45000'
			SET message_text = @me_text_1;
	END IF;
END

в) для house_info

CREATE DEFINER=`den`@`%` TRIGGER `house_info_BEFORE_INSERT` BEFORE INSERT ON `house_info` FOR EACH ROW BEGIN
IF NEW.id_abon in (select id_abon from house_info) Then
SET @me_text_2=CONCAT('id_abon for ', NEW.id_abon,' already available');
	SIGNAL sqlstate '45000'
			SET message_text = @me_text_2;
	END IF;
END

г) для period_traffic

CREATE DEFINER=`den`@`%` TRIGGER `period_traffic_BEFORE_INSERT` BEFORE INSERT ON `period_traffic` FOR EACH ROW BEGIN
IF CONCAT(NEW.id_abon,NEW.day) in (select CONCAT(id_abon,day) from period_traffic) Then
SET @me_text_3=CONCAT('id_abon for ', NEW.id_abon,' already available');
	SIGNAL sqlstate '45000'
			SET message_text = @me_text_3;
	END IF;
END

4. Создать таблицу(название ваше) с полями получеными в ходе выполнения задачи под номером восемь в DZ_les_16


create table data_set.total_traffic
 (id_abon VARCHAR(50) PRIMARY KEY,
 connection_date DATE,
 number_of_internet_devices INT,
 number_of_tv_devices INT,
 city VARCHAR(50),
 state VARCHAR(50),
 previous_number_internet int,
 previous_number_tv int,
 count_abon_city int,
 count_abon_state int,
 total_traffic_id_abon int 
 );


5. Написать триггер для таблицы из предыдущей пункта задачи.
   Параметрами будут before insert
   Задача триггера проверять на предмет дублирующей строчки, т.е. всех полей . В случае подтверждения дубликата, выводить надпись
  "row already available" .

DROP TRIGGER IF EXISTS `data_set`.`total_traffic_BEFORE_INSERT`;

DELIMITER $$
USE `data_set`$$
CREATE DEFINER=`den`@`%` TRIGGER `total_traffic_BEFORE_INSERT` BEFORE INSERT ON `total_traffic` FOR EACH ROW BEGIN
IF CONCAT(NEW.id_abon, NEW.connection_date, NEW.number_of_internet_devices, NEW.number_of_tv_devices, NEW.city, NEW.state, NEW.previous_number_internet, NEW.previous_number_tv, NEW.count_abon_city, NEW.count_abon_state, NEW.total_traffic_id_abon) in (select CONCAT(id_abon, connection_date, number_of_internet_devices, number_of_tv_devices, city, state, previous_number_internet, previous_number_tv, count_abon_city, count_abon_state, total_traffic_id_abon ) from total_traffic) Then
SET @me_text_4='row already available';
	SIGNAL sqlstate '45000'
			SET message_text = @me_text_4;
	END IF;
END$$
DELIMITER ;


6. Написать процедуру.
   Без атрибутов.
   Задача процедуры, отрабатывать скрипт полученый в ходе выполнения задачи под номером восемь в DZ_les_16 и эти данные инсертить в таблицу,
   которую создали в четвертом пункте.

USE `data_set`;
DROP procedure IF EXISTS `ins_in_total_traffic`;

USE `data_set`;
DROP procedure IF EXISTS `data_set`.`ins_in_total_traffic`;
;

DELIMITER $$
USE `data_set`$$
CREATE DEFINER=`den`@`%` PROCEDURE `ins_in_total_traffic`()
BEGIN
INSERT INTO `data_set`.`total_traffic`
select si.id_abon, connection_date, number_of_internet_devices,
    number_of_tv_devices, ac.city, st.state, 
    lag(number_of_internet_devices,1) over (partition by connection_date order by id_abon) as previous_number_internet,
    lag(number_of_tv_devices) over (partition by connection_date order by id_abon) as previous_number_tv,
    ctc.count_abon_city, stc.count_abon_state,
    total_traffic_id_abon
    from subscriber_information si
    left join abon_cities ac on ac.id_abon=si.id_abon
    left join states st on st.city=ac.city
    left join (select ac1.city, count(si1.id_abon) as count_abon_city /*тут в подзапросе подсчитывается количество абонентов в городе*/
    from subscriber_information si1
    left join abon_cities ac1 on ac1.id_abon=si1.id_abon
    group by city) ctc on ctc.city=ac.city
    left join (select st2.state, count(si2.id_abon) as count_abon_state  /*тут в подзапросе подсчитывается количество абонентов в штате*/
    from subscriber_information si2
    left join abon_cities ac2 on ac2.id_abon=si2.id_abon
    left join states st2 on st2.city=ac2.city
    group by state) stc on stc.state=st.state
    left join (select id_abon, sum(traffic_gb) as total_traffic_id_abon /*тут в подзапросе подсчитывается суммарный трафик абонентов*/
	from subscriber_information
	left join period_traffic using (id_abon)
    group by id_abon) tta on tta.id_abon=si.id_abon;
END$$

DELIMITER ;
;

